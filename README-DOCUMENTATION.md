# Simple.lisp Documentation
## Asynchronous Node-and-Wire "Hello World" Implementation

---

## Overview

`simple.lisp` implements a minimal asynchronous dataflow system using a node-and-wire architecture. The program demonstrates message-oriented concurrency by coordinating three components to produce ordered "Hello World" output.

### Key Characteristics
- **Asynchronous messaging**: Components communicate via events without direct coupling
- **Guaranteed ordering**: A de-racer component ensures deterministic output sequence
- **Flat architecture**: Single-level design with one top-level output queue (no recursive containers)
- **Minimal error handling**: Focuses on core functionality for clarity

---

## Architecture Components

### Core Classes

#### `Part`
Represents a computational component in the dataflow system.

**Slots:**
- `name`: String identifier for the part
- `inqueue`: Input queue holding incoming `Mevent` objects
- `outqueue`: Output queue holding outgoing `Mevent` objects  
- `handler`: Function reference that processes input events

**Methods:**
- `clear-outputs`: Resets the output queue to nil
- `has-input-p`: Returns true if input queue is non-empty

#### `Mevent` (Message Event)
Encapsulates a single message in the system.

**Slots:**
- `port`: Port identifier (integer or string)
- `payload`: Arbitrary data being transmitted

#### `Wire`
Defines a connection between two parts.

**Slots:**
- `sender`: `PartPort` object identifying the source
- `receiver`: `PartPort` object identifying the destination

#### `PartPort`
References a specific port on a specific part.

**Slots:**
- `part`: Reference to a `Part` instance
- `port`: Port identifier

**Constructor:**
- `wref (part-ref port-id)`: Creates a `PartPort` reference

---

## Component Handlers

### `Hello (eh mev)`
**Purpose:** Emits the string "Hello"

**Parameters:**
- `eh`: The Part instance (event handler)
- `mev`: Incoming message event (ignored)

**Behavior:** Sends "Hello" to output port ""

---

### `World (eh mev)`
**Purpose:** Emits the string "World"

**Parameters:**
- `eh`: The Part instance
- `mev`: Incoming message event (ignored)

**Behavior:** Sends "World" to output port ""

---

### `Deracer (eh mev)`
**Purpose:** Synchronizes two inputs to guarantee port 1 always outputs before port 2

**Parameters:**
- `eh`: The Part instance
- `mev`: Incoming message event

**State Management:**
Uses global state `*Deracer-state*` initialized as `(:none :none)`:
- First element: Stores message from port 1
- Second element: Stores message from port 2

**Behavior:**
1. If input arrives on port 1: stores in first position
2. If input arrives on port 2: stores in second position  
3. When both ports have received messages:
   - Outputs port 1's payload first
   - Outputs port 2's payload second
   - Resets state to `(:none :none)`

**Note:** This implements the "1→2" de-racing logic mentioned in seed information, ensuring deterministic ordering regardless of arrival sequence.

---

## Message Flow Functions

### Input Queue Operations

#### `enqueue-input (eh iport ipayload)`
Appends a new `Mevent` to a part's input queue.

**Parameters:**
- `eh`: Target part
- `iport`: Input port identifier
- `ipayload`: Message payload

#### `dequeue-input (eh)`
Removes and returns the first event from a part's input queue (FIFO).

### Output Queue Operations

#### `enqueue-output (eh oport opayload)`  
Appends a new `Mevent` to a part's output queue.

#### `dequeue-output (eh)`
Removes and returns the first event from a part's output queue.

#### `send (eh outport outpayload)`
Convenience wrapper for `enqueue-output`.

### Top-Level Output

#### `enqueue-top-level-output (oport opayload)`
Appends events to the global `*top-level-outputs*` list (final system output).

#### `output-top-level-outputs ()`
Serializes `*top-level-outputs*` to JSON and prints to standard output.

---

## Dispatcher & Routing

### `dispatcher (parts wires)`
**Core execution loop** that processes all queued messages.

**Algorithm:**
1. While any part has input:
   - For each part with input:
     - Dequeue one input event
     - Invoke the part's handler function
     - Route all outputs generated by the handler

**Parameters:**
- `parts`: List of all Part instances
- `wires`: List of Wire connections

---

### `route-outputs (p wires)`
Routes a part's output events to receivers based on wire definitions.

**Process:**
1. For each event in the part's output queue:
   - Find matching wires (same part and port)
   - Forward event to receiver(s)
2. Clear the part's output queue

**Parameters:**
- `p`: Part whose outputs are being routed
- `wires`: List of Wire connections

---

### `repurpose-mev-and-enqueue (part port sender-oriented-mev)`
Forwards an event to its destination, handling special top-level case.

**Logic:**
- If `part` is `""` (empty string): enqueue to top-level outputs
- Otherwise: enqueue to the specified part's input queue

**Note:** Uses `copy-seq` on payloads to prevent shared state issues.

---

## Main Execution Flow

### `main ()`
**Entry point** that sets up and runs the dataflow network.

**Setup:**
1. Creates three parts:
   - `part-hello`: Handler = `Hello`
   - `part-world`: Handler = `World`
   - `part-deracer`: Handler = `Deracer`

2. Defines wiring:
   ```
   Hello → Deracer (port 1)
   World → Deracer (port 2)  
   Deracer → Top-level output
   ```

3. Seeds initial inputs:
   - Empty message to Hello's input queue
   - Empty message to World's input queue

4. Executes dispatcher

5. Outputs results as JSON

**Expected Output:**
```json
[{"PORT":"","PAYLOAD":"Hello"},{"PORT":"","PAYLOAD":"World"}]
```

---

## Design Patterns

### LEGO-Like Modularity
Parts don't hardwire connections to other parts. All routing is defined externally via the `wires` list, enabling:
- **Reusability**: Parts can be reconnected in different configurations
- **Isolation**: Parts only know about their own ports
- **Namespace independence**: No global coupling between components

### Message-Oriented Concurrency
Asynchronous communication through queues provides:
- **Decoupling**: Senders don't wait for receivers
- **Buffering**: Events queue when receivers are busy
- **Order preservation**: FIFO queues maintain message sequence

---

## Limitations & Simplifications

As noted in seed information:

1. **No recursive containers**: System is flat (single-level)
2. **Minimal error handling**: Illegal states not validated
3. **ASCII function names**: Avoids Unicode (e.g., "Deracer" not "1→2")
4. **Global state**: Deracer uses `*Deracer-state*` parameter
5. **Single output queue**: Uses `*top-level-outputs*` rather than hierarchical structure

These simplifications keep the implementation focused on demonstrating core dataflow concepts.

---

## Dependencies

```lisp
(ql:quickload :uiop)     ; Common Lisp utilities
(ql:quickload :cl-json)  ; JSON serialization
```

---

## Execution

To run:
```bash
sbcl --load simple.lisp --eval "(main)" --quit
```

Or from REPL:
```lisp
(load "simple.lisp")
(main)
```

---

## Conceptual Model

```
Initial State:
  Hello.inqueue ← [""]
  World.inqueue ← [""]

Step 1: Dispatcher processes Hello
  Hello handler: outputs "Hello" to port ""
  Route: Hello."" → Deracer.1
  Deracer.inqueue ← ["Hello" on port 1]
  Deracer state: ("Hello" :none)

Step 2: Dispatcher processes World  
  World handler: outputs "World" to port ""
  Route: World."" → Deracer.2
  Deracer.inqueue ← ["World" on port 2]
  Deracer state: ("Hello" "World")

Step 3: Dispatcher processes Deracer
  Deracer handler: 
    - Both ports filled
    - Outputs "Hello" to port ""
    - Outputs "World" to port ""
  Route: Deracer."" → Top-level
  *top-level-outputs* ← ["Hello", "World"]
  Deracer state: (:none :none)

Final Output:
  [{"PORT":"","PAYLOAD":"Hello"},
   {"PORT":"","PAYLOAD":"World"}]
```

---

## Extension Points

To extend this system:

1. **Add new parts**: Create handler functions and instantiate Parts
2. **Complex routing**: Add wires with different port configurations
3. **Stateful handlers**: Use closures or global parameters (like Deracer)
4. **Multi-stage pipelines**: Chain parts through intermediate wires
5. **Hierarchical containers**: Implement nested Part structures (requires significant refactoring)

---

## Key Insights

This implementation demonstrates that:
- Complex ordered behavior can emerge from simple asynchronous components
- Explicit wiring provides flexibility without coupling
- De-racing/synchronization can be implemented as just another component
- Queue-based dispatch naturally handles arbitrary component activation order
